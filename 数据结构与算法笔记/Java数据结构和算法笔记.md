## 一，数据结构

### 1 ，数组环形队列实现思路

- 数组模拟环形队列实际就是当数组前面为空时，可把rear指针从数组最后面接着沿着环形移到数组最前面，继续添加数据。

![image-20211222212819781](note_images/image-20211222212819781.png)

- 数组中有一个空的位置原因是老师的思路是想留一个空间给rear指向，增加可读性，也可不设置空位置

### 2，链表

- 链表在内存中不一定是连续的，每个节点有一个地址指向下一个节点；
- 整个链表的内存地址和链表的第一个元素的内存地址相同；
- 链表内最后一个元素的next指针为null, 因为后面没元素了；

### 3，栈

1）用数组模拟栈的操作，遵循先入后出，后入先出的原则

作业：用链表实现栈的操作。

### 4，用栈做计算器的思路

以6+3*5-2为例，因为运算符有运算顺序，先算乘除后算加减，所以用两个栈，一个放数，一个放运算符

![1668666517245](note-images/1668666517245.png)

**思路：**

1. 从前向后扫描运算式，扫描到的数直接放入数栈，

2. 扫描到的运算符要进行判断，

   如果当前运算符栈为空则直接入栈；

   如果扫描到的运算符的优先级小于或者等于栈顶的操作符，则弹出数栈中栈顶的两个数，再弹出运算栈顶的运算符进行运算，然后把结果存入数栈，运算符直接弹栈(此操作目的是让优先级高的运算符先算)。注意数栈中两个数的运算顺序。

   如果扫描到的运算符优先级大于栈顶的符号，则直接入栈。

3. 扫描完毕后，把栈中的数按顺序和运算符进行运算，注意栈底的数在运算符前面（即把后弹出的数作为被减数，或被除的数，加和乘的话两个数的运算顺序没影响）。最后在栈底只留一个数就是运算结果。

先按上述表达式模拟下，体会这种思路。

### 5，中缀，前缀，后缀表达式

* 中缀表达式：运算符在中间的运算式，例，3+4，符合人的运算习惯
* 前缀表达式：运算符在前面 + 3 4
* 后缀表达式：运算符在后面 3 4 + (也称逆波兰表达式)

**注意：在实际开发中一般把中缀表达式转为后缀表达式**

**Reverse Polish  Notation (RPN)  逆波兰表达式**：这种表达式更适用于计算机的计算，可使用堆栈数据结构十分适合这种方式的运算，并且减少了内存的访问，而且整个运算式不用加括号。中缀表达式一般先计算哪部分都加括号表示，不加括号则按运算符的优先级。而逆波兰表达式不用括号就可以实现这种效果，它可根据规则自动按运算符的优先级计算。

逆波兰表达式的运算规则：以 6 + 2 * 3 - 4为例转换为逆波兰表达式就是 6 2 3 * + 4 -，从左只有扫描，遇到运算符则把运算符左边的两个数按运算符计算，再把运算结果放回原位，去除使用过的运算符。

例：中缀：3 - 4 * 5   转换为后缀表达式是： 3 4 5 * -

​       中缀：  (3 - 4) * 5  则是 ：  3 4 - 5 *，

 由此可见逆波兰表达式无歧义的实现了无论是带括号或不带括号中缀表达式的转换。

### 6，递归

使用递归注意事项

一定要有一个条件终止递归，否则会造成内存泄漏；

写递归代码思路总结：

1，首先递归是跟栈的特性是一样的，最后被调用的方法，最先执行，因此根据这个特点一定加好判断条件看最后一个方法什么情况下弹栈

2，最后一个方法执行完后所有语句后才会弹栈，思路模拟时从最后一个弹栈开始。例：

```java
	descendPrint(123456);
	//正序打印，利用递归，栈的特点(LIFO)
	public static void descendPrint(int number){
		//这里就是判断当参数小于等于9时，递归的最后一个方法打印完数组，return,弹栈，后续的所有方法持续弹栈
        if(number <= 9){
			System.out.println("descend==>" + number);
			return;
		}
		descendPrint(number / 10);
		System.out.println("descend==>" + number % 10);
	}
```





**1）迷宫回溯出现的问题：**

个人初步代码RecursionTest中实现了迷宫，但如果走不到指定的终点就不会反馈结果，即没有把走不通的路设置成“3”，没有利用到递归的“后进先出”的特性，即没有利用回溯。

**2）八皇后问题：**

规则：在8x8的棋盘上，放置8个皇后，使其不能互相攻击，即任意两个皇后都不能在同一行，同一列或统一对角斜线上。

- 解题时也用到了递归回溯，当到第n个皇后时，要检查之前n-1行的是否符合要求，不符合的话在从0到n行重新摆放，直到从0到n这几个皇后都不能互相攻击。
- 第一个皇后放第一行第一列时，就先压栈，至放第八个皇后，放这第八个时会从第一个检查，如果不符合要求，第一个会放第二列。
- 一次for循环，就执行一次递归；
- 如果到最后一个第八个皇后，检查之前的七行里的都可以攻击，则递归到头，开始弹栈，一直弹到调用递归哪一行，注意不一定是第一行，有可能是第二行第三列，不合格就循环到第二行第四列在递归；

结合程序注释理解。

![八皇后图例](note-images/八皇后图例.png)



## 二，算法

#### 学习算法的方法

- 首先把复杂的算法拆解成简单的步骤。从最简单的步骤做起，先写手动一步步的步骤，然后再加for或者while循环自动完成。
- 一定要画图把思路理清楚，才做，不要上来就试着写，写不对。

### 1，时间频度

用T(n)表示。

### 2，常见的时间复杂度

时间复杂度用O(n)表示。一般说时间复杂度指的是最坏情况下的时间复杂度，因为不可能出现比最坏情况下时间还慢的情况。

以下的从上到下时间复杂度递增。

(1)常数阶：O(1)，这种复杂度不随变量的变化而变化。例:

```java
int i = 10;
public void doSome(){
    int j = i + 1;
}   
```

(2)对数阶: $O(log_2n),O(log_3n)$ ,  底数可以是2，也可以是其他自然数。

例：2的x次方小于n，表示循环x次之后可得到结果。

```java
int i = 1;
while(i < n){
    i *= 2;
}
```

(3)线性阶: O(n)， 例：复杂度由n来决定的。

```java
for(int i = 0; i < n; i++){
    System.out.println();
}
```

(4)线性对数阶：指的是线性阶和对数阶相乘。
$$
O(nlog_2n)
$$
例：在for循环里嵌套对数阶的while循环

```java
int j = 1;
for(int i = 0; i < n; i++){
    while(j < n){
        j *= 2;
    }
}
```

(5)平方阶
$$
O(n^2)
$$
例：两层for循环，每层循环n次

```java
for(int i = 0; i < n: i++){
    for(int j = 0; j < n; j++){
        
    }
}
```

(6)立方阶: 跟平方阶同理，三层for循环，每层循环n次
$$
O(n^3)
$$
(7)k次方阶： 也跟平方阶同i，k层for循环，每层循环n次
$$
O(n^k)
$$
(8)指数阶：时间复杂度最大，尽量不要在程序中使用
$$
O(k^n)
$$
例：随着n的增大，程序运行的次数呈指数级上升。

```java
public long sum(int n){
    if(n <= 1){
        return 1;
    }
    return sum(n - 1) + sum(n - 2);
}
```

 (9)阶乘： O(n!)

### 3，空间复杂度

指程序算法所耗费的存储空间。

一般用空间换时间，提高程序运行效率。Redis, memecache等用的就是次策略。

### 4，排序算法

#### 1) 排序分为内部排序算法和外部排序算法

​	(1)内部排序：指把所有数据拿到内存中进行排序。

​    **内部排序共八种：**

​	冒泡排序，选择排序(Select Sort)。 （属于交换排序类型）

​	直接插入排序(Insert Sort)，希尔排序(Shell Sort，对直接排序进行了优化)。 （插入排序类型）	

​	简单选择排序，堆排序。（选择排序大类型）

​	归并排序。  

​	基数排序。	

​	(2)外部排序：使用内存和硬盘空间结合的方式进行排序，用于较大的数据。

#### 2) 内部排序

##### 2.1 Shell Sort 希尔排序

思路分析图，结合代码笔记理解。

<img src="note-images/1671155030824.png" alt="1671155030824" style="zoom:50%;" />

##### 2.2 QuickSort快速排序

最大时间复杂度$O(n^2)$

平均时间复杂度$nO(log_2n)$

##### 2.3 MergeSort 归并排序

最大，平均，最优时间复杂度都是$nO(log_2n)$，属于对数阶，速度很快。

思路：

该算法采用分治策略，先把数组拆分成最小的单位，然后再合并，分而治之。

用到到了递归类进行分的实现。

思路图：

![1671589142714](note-images/1671589142714.png)



- 当分到只有一个元素时，就进行比较，递归到最后时弹栈就执行比较后排序的方法，例，先比较8(index:0)和4(index:1)，比较完放到临时数组，然后再放回原数组的下标里。

- 1，1排序合并-->2,2排序合并-->直到最后。关键注意体会递归的特性，理解最后弹栈的用法和原理。

合并思路图，这是最后一次合并的示意图。

![1671589530951](note-images/1671589530951.png)

##### 2.4 基数排序(Radix Sort)

基数排序时间复杂度$O(n*k)$。n：数据规模，k：”桶“的个数。注：计数排序和桶排序跟基数排序类似。

1. 基数排序属于“分配式排序”，也称桶排序。它属于效率较高的有“稳定性“的排序，”稳定性“指如果原数组中arr[i] >arr[j] 而且arr[i]在arr[j]之前，那在排序的过程中他们的相对位置一直保持不变，此称作”稳定性“。

2. 基数排序实质使用空间复杂度换取时间复杂度，占用内存较大，使用时注意。

3. 个人整理思路如下：

   ![1671699204916](note-images/1671699204916.png)

3）几种排序算法的比较

<img src="note-images/1671760794364.png" alt="1671760794364"  />

#### 5，查找算法

1) 线性查找法

2) 二分查找法

3) 插值查找法

4) 斐波那契查找算法

斐波那契查找算法也称黄金分割查找法，斐波那契数列的元素数值之比无限接近于黄金比例0.618。

斐波那契查找算法在插值查找算法的基础上对mid的值的算法进行了优化，使之符合黄金比例。

注意，使用时有时候数组不够长找不到黄金分割点，需要扩容数组。

思路：

例，原数组{1，2，3，4，5，6，7，8，9，10，11，12，13，14，15}

1，由斐波那契数列{0,1,1,2,3,5,8,13,21,43.....}，可知arr[k] = arr[k-1] + arr[k-2]。数列内相邻元素之比接近于0.618这个黄金分割点。越往后越接近。

​	由arr[k] = arr[k-1] + arr[k-2]  可得 arr[k] - 1 = （arr[k-1]  - 1) + (arr[k-2] -1) + 1，之所以换成这样的公式是因为数组下标从0开始，这样更好转化，例 arr[6] = arr[5] + arr[4]==> 13=8+5 ==> 13-1= (8-1) + (5-1) + 1,前面8-1是黄金分割点的下标，后面 (5-1) + 1是另一段。即可得mid = begin + arr[k-1]  - 1

2,  原数组的长度按斐波那契数列公式进行分割，即可得到接近黄金分割点的位置，类似于原来插值查找法的mid，实际这个mid并不是中间下标，而是原数组按斐波那契公式找到的接近黄金分割点的地方。

例，原数组长度，我们就找斐波那契数列中的“8, 13”，然后8+13=21 >15，斐波那契数列值的综合大于原数组长度的话需要扩容原数组，扩容的值就等于原数组的最后一个元素值(因为是递增数组)。这样第一次分割就能按8:13找分割点了。

​    第二次分割在从斐波那契数列中往前找。

3, 实际原理跟插值查找法类似，只是把这个比例换成了斐波那契数列中相邻两个元素的前后比值而已。