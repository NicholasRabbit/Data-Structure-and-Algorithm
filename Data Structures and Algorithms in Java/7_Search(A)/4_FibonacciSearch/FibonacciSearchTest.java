

import java.util.Arrays;

/*
* 利用斐波那契数组来进行查找的算法
* 注意：是利用斐波那契数组内相邻值的比例来进行分割的，
* 因为斐波那契相邻两个元素的比无限接近于0.618这个换进比例，所以也称它为黄金分割查找算法。
* 
* 思路：
* 
* 例，原数组{1，2，3，4，5，6，7，8，9，10，11，12，13，14，15}
* 1，由斐波那契数列{0,1,1,2,3,5,8,13,21,43.....}，可知arr[k] = arr[k-1] + arr[k-2]。
*  数列内相邻元素之比接近于0.618这个黄金分割点。越往后越接近。
​*  由arr[k] = arr[k-1] + arr[k-2]  可得 arr[k] - 1 = (arr[k-1]  - 1) + (arr[k-2] -1) + 1，
*  之所以换成这样的公式是因为数组下标从0开始，这样更好转化，
*  例 arr[6] = arr[5] + arr[4]==> 13=8+5 ==> 13-1= (8-1) + (5-1) + 1,
*  前面8-1是黄金分割点的下标，后面 (5-1) + 1是另一段。即可得mid = begin + arr[k-1]  - 1
* 
* 2,原数组的长度按斐波那契数列公式进行分割，即可得到接近黄金分割点的位置，类似于原来插值查找法的mid，
*  实际这个mid并不是中间下标，而是原数组按斐波那契公式找到的接近黄金分割点的地方。
*  例，原数组长度，我们就找斐波那契数列中的“8, 13”，然后8+13=21 >15，
*  斐波那契数列值的综合大于原数组长度的话需要扩容原数组，扩容的值就等于原数组的最后一个元素值(因为是递增数组)。
*  这样第一次分割就能按8:13找分割点了。
*  第二次分割再根据判断从斐波那契数列中往左或右找。
* 
* 3,实际原理跟插值查找法类似，只是把这个比例换成了斐波那契数列中相邻两个元素的前后比值而已。
*   
* 
*/
public class FibonacciSearchTest {
	
	public static void main(String[] args){
		
		int[] array = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
		int index = fiboSearch(array,12);
		System.out.println("index==>" + index);
	
	}

	//
	public static int fiboSearch(int[] array,int value){
		
		//1，首先获取一个斐波那契数列数组
		int[] fiboArray = FibonacciArray.createFibonacci(20);

		
		/*
		* 2.1 计算公式整理转换。
		* 根据斐波那契数列的公式 fiboArray[k] = fiboArray[k-1]+fiboArray[k-2]
		* 求出对应下标的公式，fiboArray[k]-1 = (fiboArray[k-1]-1)+(fiboArray[k-2]-1) + 1
		*                                        
		* 因为要把斐波那契的两个相邻元素值的和原数组元素的下标对应起来，好求分割点，所以公式两边都减1
		*/
		
		//2.2,从斐波那契数组中找下标对应的值，和原数组比较，有可能刚好等于数组长度
		//  如果不能与就找出一个比数组长度大的，不能比原数组长度小
		int begin = 0;
		int end = array.length - 1;
		int mid = 0;
		int k = 0;  //斐波那契数组初始下标
		//当斐波那契数组内的值刚好比原数组长度大时就退出循环，此时k++已进行运算，下标已移动到大的这个值处
		while(end > fiboArray[k] - 1){  
			k++;
		}

		//2.3 数组临时扩容，当找到的斐波那契数组中的值比原数组长时就需要扩容至和这个值一致。
		int[] tempArray = Arrays.copyOf(array,fiboArray[k]);  //扩出的位置初始用0赋值
		

		//2.4 把多出的下标都赋值为原数组的最后一个值，即最大值(倒序情况是最小值)，因为是有序数组所以要把它们都赋值为
		for(int i = end + 1; i < tempArray.length; i++){
			tempArray[i] = array[end];  
		}
		
		
		/*
		* 3,开始循环遍历查找
		*/
		while(begin <= end){
			
			//3.1 求出分割点，这里用mid代替，并不是中间点
			//注意：按照斐波那契数列，前面相邻数的比例不一定是0.618，只是越靠后越接近。
			mid = begin + fiboArray[k-1]-1;  //A
			
			//向左查找，即把左边的数组当成一个整体，找它的黄金分割点
			if(tempArray[mid] > value){  //注意这里是:tempArray[mid]
				end = mid - 1;
				/*
				* 这里k--指下次循环时，斐波那契数组的值左移一位，再通过A处的公式找到环境分割点
				* 例：{1,1,2,3,5,8,13,21,43}，43长度的数组分割点在21(下标21-1)，如果array[mid] > value
				* 则从左边长度21数组中再找，就需要分割，为13,8，所以这个下标左移k--，在A处循环分割。
				*/
				k--;   
			//向右查找
			}else if(tempArray[mid] < value){
				begin = mid + 1;
				//因为斐波那契数组：arr[k] = arr[k-1] + arr[k-2]，
				//所以向右查找就得k-=2,再把右边的当成一个整体，在A处循环分割。
				k -= 2;  
			}else{
				//找到结果返回，
				if(mid < end){
					return mid;
				}else{
					//返回high是因为数组临时扩容后面添加的元素的值=arr[high]，
					//找到的下标比high还大，说明要找的值就是arr[hign]
					return end;    
				}

			}
		}
		
		return -1;
		
	}



}