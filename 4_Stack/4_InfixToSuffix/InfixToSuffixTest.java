
import java.util.*;

/*
* 中缀转后缀表达式练习：
* 因为中缀表达式符合人的思考习惯，而且输入到模拟计算机内的就是中缀表达式。
* 但是，计算机的栈使用后缀表达式计算的效率高，内存占用小，所以要把中缀表达式转为后缀表达式。
* 步骤：
* 1，需要一个链表（或数组）用来放生成的后缀表达式，一个符号栈（用来临时存储符号，括号）
* 2，从左至右扫描中缀表达式，遇到数字放入链表；
*    1)遇到符号则判断，如果栈内为空则直接入栈；
*    2)如果栈内不为空，分以下集中情况
*      - 左括号“(”直接入栈；
*      - 运算符则比较优先级，当前扫描到的运算符优先级大于栈顶的符号则直接入栈，
*	   - 如果优先级小于或等于栈顶则弹栈一次（注意只弹一次），把弹出的符号添加到链表里，然后再与栈顶的判断；
*      - 扫描到右括号")"，则弹栈到左括号，把弹出的运算符依次添加到链表，括号扔掉不添加（后缀表达式不用括号）；
*	   最后把剩下的符号依次弹栈加入到链表内。
* 画图模拟下流程，理清思路再做。
* InfixToSuffixUtil里实现上述操作。
* 3，个人写的思路跟老师的一致，但实现代码不一样。
*    本代码中运算符是靠对应的int值来判断的，有漏洞，因为如果有超大值超出int范围的话，强转结果可能是43（加号的值），那这个数就被当作加号判断了。
*/
public class InfixToSuffixTest {

	
	//以26+15+(6+4)*16/5-7 结果 = 66为例
	
	public static void main(String[] args){
		
		String expInfix = "26+15+(6+4)*16/5-7";  //后缀表达式为：26 15 + 6 4 + 16 * 5 / + 7 -
		//String expInfix = "3+5*6-10";	  //后缀：3 5 6 * + 10 - 
		List<String> expSuffix = InfixToSuffixUtil.toSuffix(expInfix);
		String result = CalculatorUtil.calculate(expSuffix);
		System.out.println("result==>" + result);
	}

	
}